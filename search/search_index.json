{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Liminal ORM","text":""},{"location":"#overview","title":"Overview","text":"<p>Liminal ORM<sup>1</sup> is an open-source Python package that builds on Benchling's LIMS<sup>2</sup> platform and provides a simple, code-first approach for synchronizing and managing your Benchling schemas. Join our Slack community here!</p> <p>Liminal provides an ORM framework using SQLAlchemy along with a schema migration service inspired by Alembic. This allows you to define your Benchling schemas in code and create a single source of truth that synchronizes between your upstream Benchling tenant(s) and downstream dependencies. By creating a standard interface and through using one-line CLI<sup>3</sup> commands, Liminal enables a code-first approach for managing Benchling tenants and accessing Benchling data. With the schemas defined in code, you can also take advantage of the additional capabilities that the Liminal toolkit provides. This includes:</p> <ul> <li>The ability to run migrations to your Benchling tenant(s) through an easy to use CLI.</li> <li>One source of truth defined in code for your Benchling schema model that your many Benchling tenants can stay in sync with.</li> <li>Easy to implement validation rules to reflect business logic for all of your Benchling entities.</li> <li>Strongly typed queries for all your Benchling entities.</li> <li>CI/CD integration with GitHub Actions to ensure that your Benchling schemas and code are always in sync.</li> <li>And more based on community contributions/feedback :)</li> </ul> <p>Benchling is an industry standard cloud platform for life sciences R&amp;D. Liminal builds on top of Benchling's platform and assumes that you already have a Benchling tenant set up and have (or have access to) an admin user account. If not, learn more about getting started with Benchling here!</p> <p>If you are a Benchling user, try out Liminal by following the quickstart guide! Reach out in the Discussions forum with any questions or to simply introduce yourself! If there is something blocking you from using Liminal or you're having trouble setting Liminal up, please share in Issues or reach out directly (contact information below). You can expect responses within 48 hours :)</p> <p>Nirmit Damania is the creator and current maintainer of Liminal (I post Liminal updates to Discussions and my LinkedIn). Most importantly, you have the ability to influence the future of Liminal! Any feedback, positive or negative, is highly encouraged and will be used to steer the direction of Liminal. Refer to the Contributing guide to learn more about how you can contribute to Liminal.</p> <p>\u2b50\ufe0f Leave a star on the repo to spread the word! If you or your organization use Liminal, please consider adding yourself or your organization to the Users list.</p>"},{"location":"#mission","title":"Mission","text":"<p>The democratization of software in Biotech is crucial. By building a community around complex, yet common, problems and creating open-source solutions, we can work together to tackle these challenges together and enable faster innovation in the industry. By breaking down the silos between private platforms, we can enable a more dynamic and open ecosystem. This was the motivation for Liminal's creation. Liminal's goal is to create an open-source software product that enables a standard, code-first approach to configuration and change management for LIMS systems. We started with Benchling, but the goal is to make Liminal the go-to solution for any LIMS system.</p>"},{"location":"#direct-contact-information","title":"Direct contact information","text":"<ul> <li>Liminal Community Slack group: Join here</li> <li>Email: opensource@dynotx.com</li> <li>LinkedIn: Nirmit Damania</li> </ul>"},{"location":"#footnotes","title":"Footnotes","text":"<p>ORM<sup>1</sup>: Object-Relational Mapper. An ORM is a piece of software designed to translate between the data representations used by databases and those used in object-oriented programming. In this case, Liminal provides an ORM layer built specifically for Benchling that allows for users to quickly and easily define Benchling entities in code. SQLAlchemy is the underlying ORM that Liminal uses to interact with your Benchling tenant(s) and is an open-source software that is an industry standard software.</p> <p>LIMS<sup>2</sup>: Laboratory Information Management System. A LIMS is a piece of software that allows you to effectively manage samples and associated data. Benchling is an industry-leading LIMS software.</p> <p>CLI<sup>3</sup>: Command Line Interface. A CLI is a piece of software that allows you to interact with a software program via the command line. Liminal provides a CLI that allows you to interact with your Liminal environment. This project uses Typer to construct the CLI</p>"},{"location":"contributing/","title":"Contributing to Liminal ORM","text":"<p>Thank you in advance for your contribution to Liminal! A contribution of any kind has an impact on the community. Remember to star the repo on GitHub and share Liminal with your colleagues to grow our community!</p>"},{"location":"contributing/#ways-to-contribute","title":"Ways to Contribute","text":"<p>Everyone in the community has the ability to influence the roadmap of Liminal, no matter how big or small the contribution. Below are some ways you can contribute:</p> <ul> <li>Code Contribution: Help us improve the codebase by fixing bugs, adding new features, or improving documentation.</li> <li>Documentation: Help us improve the documentation by adding missing information, improving existing documentation, or raising an issue to update the documentation where needed.</li> <li>Raising an Issue: Report bugs, suggest features, or provide feedback to help us improve.</li> <li>Spread the Word: Leave a star on the repo in GitHub or spread the word with coworkers to help grow and cultivate the community.</li> <li>Add yourself as a User: If your project or organization uses Liminal, add yourself to USERS.md. This is a great way to help us prioritize Liminal's roadmap, and get first dibs on new features ;).</li> </ul>"},{"location":"contributing/#setup","title":"Setup","text":"<p>If you are interested in contributing to Liminal, please follow the steps below to setup the Liminal repository locally.</p> <ol> <li> <p>Fork the Liminal repository and sync to upstream. Instructions here: Fork a repo</p> </li> <li> <p>Install Poetry</p> </li> </ol> <p>Use the Poetry Installation guide</p> <ol> <li> <p>Install Liminal dependencies</p> <p><code>poetry install --all-extras</code></p> </li> <li> <p>Ensure python version matches Liminal's supported version</p> <p>Supported python versions of Liminal can be found in pyproject.toml. We recommend using pyenv to manage python versions.</p> </li> <li> <p>Start developing :)</p> </li> </ol>"},{"location":"contributing/#development-cycle","title":"Development cycle","text":"<p>Liminal uses <code>pre-commit</code> hooks for enforcing formatting, linting, and mypy. Formatting and linting is done using <code>ruff</code> Every commit requires these to pass and you can run them manually using <code>pre-commit run</code> (use <code>-a</code> flag to run on all files). Commit with the <code>--no-verify</code> flag to avoid running the pre-commit hooks.</p> <p>Please include tests when adding new functionality. Liminal uses <code>pytest</code> for testing. Run this using <code>pytest liminal/</code> to run all tests. All tests must pass in order to merge in a Pull Request.</p> <p>If making changes to the documentation (which is created using <code>MKDocs-material</code>). Host and get a live preview of website using <code>mkdocs serve</code>.</p>"},{"location":"contributing/#making-a-pull-request","title":"Making a Pull Request","text":"<p>Contributions to the codebase must be made by submitting a Pull Request</p>"},{"location":"future-direction/","title":"Future direction","text":"<p>Please check the Issues page for the latest updates on what's coming in the near future!</p>"},{"location":"future-direction/#roadmap","title":"Roadmap","text":"<p>This roadmap is based on community feedback. If there is a feature or something blocking you from using Liminal, please reach out to me and it will help me prioritize the Liminal roadmap!</p> <ul> <li>Achieve 100% parity with Entity Schemas (Current: ~80%)<ul> <li>Name template</li> <li>Inventory settings</li> </ul> </li> <li>Expand coverage to all Benchling schema types<ul> <li>Container schema</li> <li>Box schema</li> <li>Plate schema</li> <li>Location schema</li> </ul> </li> <li>Liminal automatically generates user-friendly validation reports</li> <li>Make validators on entity schemas labeled as decorators</li> </ul> <p>The grand vision of Liminal is to expand its coverage to other LIMS systems. Liminal could become a community driven product that standarizes a code-first approach to interact with different LIMS systems. This would become a terraform-like product that allows mapping between different LIMS systems and allows users to control and define how they want to interact with their LIMS systems.</p>"},{"location":"release-notes/","title":"Release notes","text":"<p>For full release notes, please visit the GitHub Releases page. Release versions follow semantic versioning. This page will document only Major and Minor version changes that require user action, such as migration steps, when upgrading to the new version.</p>"},{"location":"release-notes/#v110","title":"v1.1.0","text":""},{"location":"release-notes/#upgrade-notes","title":"Upgrade Notes","text":"<ul> <li>PR #64: makes query function optional in schema classes.<ul> <li>Remove query functions from schema classes, unless you have custom logic.</li> </ul> </li> <li>PR #72: block warehouse name changes to operations.<ul> <li>BenchlingConnetion now takes in <code>warehouse_access</code> parameter. If you do not have warehouse access on your Benchling tenant, set this to <code>False</code>.</li> </ul> </li> <li> <p>PR #53: move field wh name to base field props.</p> <ul> <li>Update historical revision files with changed operation signatures.</li> </ul> <pre><code># Replace UpdateEntitySchemaName with...\nUpdateEntitySchema('old_warehouse_name', \n    BaseSchemaProperties(warehouse_name='new_warehouse_name'))\n\n# Replace UpdateEntitySchemaFieldName with...\nUpdateEntitySchemaField('entity_schema_warehouse_name', \n    'field_warehouse_name', \n    BaseFieldProperties(warehouse_name='new_warehouse_name'))\n\n# CreateEntitySchemaField no longer takes wh_field_name as a parameter. \n# Now gets passed in via BaseFieldProperties.\nCreateEntitySchemaField('entity_schema_warehouse_name', \n    BaseFieldProperties(warehouse_name='new_warehouse_name', ...))\n\n# CreateEntitySchema takes in a list of fields instead of dict[str, Benchling FieldProperties]\nCreateEntitySchema(BaseSchemaProperties(...), [BaseFieldProperties(...), ...])\n</code></pre> </li> <li> <p>PR #63: numpy and pandas version tightening.</p> <ul> <li>numpy = \u201c^1.23.5\u201d</li> <li>pandas = \"&gt;=1.5.3\" --&gt; \u201c^1.5.3\"</li> </ul> </li> </ul>"},{"location":"case-studies/dynotx-recommended-sop/","title":"DynoTx Recommended SOP","text":"<p>Below, you will find the SOP Dyno Therapeutics follows for using Liminal to manage their Benchling schemas. This SOP assumes that you have already set up Liminal.</p>"},{"location":"case-studies/dynotx-recommended-sop/#dyno-therapeutics-benchling-change-management-sop","title":"Dyno Therapeutics Benchling Change Management SOP","text":"<p>(since 07.24.2024)</p> <p>Dyno's Benchling tenants are set up as a Dev, Test, and Prod environments. All scientists and a select number of engineers have access to the PROD tenant, and all work is done in PROD. The Dev and Test tenants are used for development and testing of new features before merging into PROD. Liminal is used to keep the Test and Prod tenants in sync, while Dev is used for development/testing. Dyno uses a ticketing system through a Slack channel for Benchling schema change requests. The Benchling Admin is responsible for managing the Benchling environment and implementing the requested changes.</p> <p>Let's say a change has to be made to a Benchling schema...</p>"},{"location":"case-studies/dynotx-recommended-sop/#pre-work","title":"Pre-work","text":"<ol> <li> <p>If the change is non-trivial, the Benchling Admin will modify the Liminal schemas in the Dev tenant on the Benchling UI. This allows them to try changes and iterate in a safe environment until the final changes are settled.</p> </li> <li> <p>Once they are confident in the exact changes needed to be made to the Liminal schemas, they move onto the migration step. As a safeguard, Liminal offers the ability to revert back to the original state automatically.</p> </li> </ol>"},{"location":"case-studies/dynotx-recommended-sop/#migration","title":"Migration","text":"<ol> <li> <p>Make change(s) to the Liminal schemas in code.</p> </li> <li> <p>Run <code>liminal autogenerate PROD 'description'</code>. This will generate a revision file, and create a list of operations to migrate PROD to be in sync with the schemas defined in code.</p> <p>Why point to PROD?</p> <p>The PROD tenant is the tenant that users interact with, meaning it should always be in sync with the code. This means when we autogenerate against PROD, we are comparing the Liminal schemas in code against the actual Benchling schemas in PROD. <code>autogenerate</code> creates a diff (a computed difference) and generates a list of operations for what needs to be done to make the PROD tenant match the Liminal schemas in code.</p> </li> <li> <p>Create a PR in GitHub with schema changes and revision file.</p> </li> <li> <p>Run <code>liminal upgrade TEST</code>. Dyno keeps TEST in sync with PROD, for easy testing of new features. This runs the generated list of operations in the generated revision file against the TEST tenant.</p> </li> <li> <p>Review the changes in TEST.</p> </li> <li> <p>If the changes look good, run <code>liminal upgrade PROD</code>. This will apply the operations to the PROD tenant.</p> </li> <li> <p>Add screenshots of successful migration to the PR.</p> </li> <li> <p>Merge the PR.</p> </li> </ol>"},{"location":"case-studies/dynotx-recommended-sop/#reverting-tenant-to-the-current-state","title":"Reverting Tenant to the current state","text":"<p>Let's say you are making some changes in the DEV tenant, but you need to revert back to the current state of your schemas defined in code. Liminal offers a way to quickly migrate the tenant back/forward to the current state.</p> <ol> <li> <p>Run <code>liminal autogenerate TEST 'description'</code>. This will generate a revision file, and create a list of operations to migrate TEST to be in sync with the schemas defined in code.</p> </li> <li> <p>Run <code>liminal upgrade TEST</code>. This will apply the operations to the TEST tenant.</p> </li> <li> <p>Delete the revision file created in step 1.</p> </li> </ol> <p>Why delete the revision file?</p> <p>Liminal only keeps of 1 linear history of changes. This \"cleanup\" migration is not part of the linear history, so it should be deleted.</p>"},{"location":"getting-started/downgrading/","title":"Downgrading","text":"<ol> <li> <p>Let's say you want to revert changes made to your Benchling tenant. You can do this by downgrading to a previous revision. This will run the downgrade operations defined in the revision file and revert the tenant back to the previous state. This is a useful tool to revert accidental changes made to your Benchling tenant and maintain the history of your schema changes.</p> </li> <li> <p>In your CLI in Liminal's root directory (that contains the <code>liminal/</code> path), run the following command:</p> <pre><code>liminal downgrade &lt;benchling_tenant&gt; &lt;downgrade_descriptor&gt;\n</code></pre> <p>The downgrade descriptor</p> <p>The downgrade descriptor can be one of:</p> <ul> <li><code>revision_id</code>: The ID of the revision to downgrade to. Ex: <code>\"d28335bffaba\"</code></li> <li><code>-&lt;n&gt;</code>: The <code>n</code> revisions before the current revision. Ex: <code>-1</code> will downgrade to the revision before the current revision.</li> </ul> </li> </ol>"},{"location":"getting-started/first-migration/","title":"First migration","text":"<ol> <li> <p>You have changes you need to make to your Benchling schema model. Manipulate your schema classes defined in code and make changes where needed. When you are finished, you are ready to run your first migration!</p> <p>Manipulating schemas</p> <p>For an overview of what is covered by Liminal and can be defined in code, please see the Reference section to get detailed documentation on the different class properties. When making changes, anything that Liminal covers should be manipulated in code. Otherwise, your schemas defined in code will become out of sync with your Benchling tenant. Any properties that Liminal does not cover should be manipulated through the Benchling UI, as Liminal cannot track changes to these properties.</p> </li> <li> <p>In your CLI in Liminal's root directory (that contains the <code>liminal/</code> path), run the following command:</p> <pre><code>liminal upgrade &lt;benchling_tenant&gt; &lt;upgrade_descriptor&gt;\n</code></pre> <p>Example: <code>liminal upgrade prod \"remove dough column from pizza schema\"</code>.</p> <p>This will automatically generate a new revision file in the <code>versions/</code> directory. This revision file defines the set of steps (or \"operations\") that will be needed to make the targeted Benchling tenant up to date with the changes made in the schema model.</p> <p>If I have multiple Benchling tenants, do I have to run <code>autogenerate</code> for each tenant?</p> <p>No, Liminal only keeps a single thread of revision history so that each revision file has a linear link. In the case of multiple tenants that need to stay in sync together, we recommend pointing <code>autogenerate</code> at your production tenant, or the tenant that acts as the production environment. This will ensure there is a consistent history that your other tenants can follow. When ready, you can then apply the revision to all your tenants.</p> </li> <li> <p>Review the generated revision file and set of operations to ensure that it is accurate.</p> </li> <li> <p>Once you've reviewed the revision file and are ready to apply the changes, run the following command:</p> <pre><code>liminal upgrade &lt;benchling_tenant_name&gt; &lt;upgrade_descriptor&gt;\n</code></pre> <p>The upgrade descriptor</p> <p>The upgrade descriptor can be one of:</p> <ul> <li><code>head</code> to upgrade to the latest revision.</li> <li><code>revision_ID</code> to upgrade to a specific revision. Ex: <code>\"c3a9cd009713\"</code></li> <li><code>+&lt;n&gt;</code> to upgrade to the revision <code>n</code> revisions after the current revision. Ex: <code>\"+1\"</code> will upgrade to the revision after the current revision.</li> </ul> <p>In this case, we run <code>liminal upgrade prod head</code> to upgrade to apply the revision to the production tenant.</p> <p>Tip</p> <p>If you have multiple Benchling tenants, you can run <code>liminal upgrade</code> multiple times pointing to different tenants to upgrade them. It is recommended to run against your test tenant first to ensure the changes are applied as expected.</p> </li> <li> <p>You should see output indicating that the revision was applied successfully. Check your Benchling tenant to ensure the changes were applied as expected!</p> </li> </ol>"},{"location":"getting-started/first-migration/#example-revision-file","title":"Example Revision File","text":"<pre><code>import liminal.external as b\n\n# revision identifiers, used by Liminal.\nrevision = \"c3a9cd009713\"\ndown_revision = \"d28335bffaba\"\n\n\n# ### commands auto generated by Liminal - please review (and adjust if needed)! ###\ndef upgrade() -&gt; list[b.BaseOperation]:\n    return [b.ArchiveEntitySchemaField('pizza', 'dough')]\n\n# ### commands auto generated by Liminal - please review (and adjust if needed)! ###\ndef downgrade() -&gt; list[b.BaseOperation]:\n    return [b.UnarchiveEntitySchemaField('pizza', 'dough')]\n</code></pre> <p>This looks correct! I wanted to archive the <code>dough</code> column from the <code>pizza</code> entity schema.</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Install Liminal via pip:</p> <pre><code>pip install liminal-orm\n</code></pre> <p>Install Liminal via github:</p> <pre><code>python -m pip install git+https://github.com/dynotx/liminal-orm.git --ignore-installed\n</code></pre>"},{"location":"getting-started/installation/#pypi-stats","title":"PyPI Stats","text":""},{"location":"getting-started/prerequisites/","title":"Prerequisites","text":"<ol> <li> <p>Benchling Admin Account: Liminal builds on top of Benchling's LIMS system. You will need access and credentials to an admin account for your Benchling tenant(s). Liminal needs credentials with full admin priveleges in order to manipulate Benchling schemas through their API.</p> </li> <li> <p>SSO optional: A requirement for Liminal's migration service to work is for your Benchling tenant to have SSO optional or disabled. At the moment, a part of Liminal's API connection requires the admin email and password and is unable to be authenticated when SSO is required. You can message Benchling support to request that your tenant be configured to be SSO optional or disabled.</p> </li> <li> <p>Python: Liminal is built using Python. You will need Python 3.9 or later installed on your machine.</p> </li> </ol>"},{"location":"getting-started/prerequisites/#notes","title":"Notes","text":"<ul> <li>It is important to note that Liminal only supports coverage for Benchling entity schemas and dropdowns at the moment. Future plans are to expand support to include all Benchling schema types and have 100% parity with entity schemas. Leave a comment on the Discussions forum on your vote for what should be supported next, or what is blocking you from using Liminal!</li> </ul>"},{"location":"getting-started/setup/","title":"Setup","text":"<ol> <li> <p><code>cd</code> into the directory where you want to instantiate your Liminal environment. This will be the root directory where your schemas will be defined. Note: the Liminal CLI must always be run from within this root directory.</p> </li> <li> <p>Run <code>liminal init</code> in your CLI to initialize your Liminal environment. This will create a <code>liminal/</code> directory that contains an <code>env.py</code> file and a <code>versions/</code> directory.</p> <ul> <li>The <code>env.py</code> file is used to store your Benchling connection information.</li> <li>The <code>versions/</code> directory is used to store your revision files.</li> </ul> </li> <li> <p>Populate the <code>env.py</code> file with your Benchling connection information, following the instructions in the file. For example:</p> <pre><code>from liminal.connection import BenchlingConnection\n\n    PROD_CURRENT_REVISION_ID = \"12b31776a755b\"\n\n    # It is highly recommended to use a secrets manager to store your credentials.\n    connection = BenchlingConnection(\n        tenant_name=\"pizzahouse-prod\",\n        tenant_alias=\"prod\",\n        current_revision_id_var_name=\"PROD_CURRENT_REVISION_ID\",\n        api_client_id=\"my-secret-api-client-id\",\n        api_client_secret=\"my-secret-api-client-secret\",\n        internal_api_admin_email=\"my-secret-internal-api-admin-email\",\n        internal_api_admin_password=\"my-secret-internal-api-admin-password\",\n)\n</code></pre> <ul> <li>Required: The <code>api_client_id</code> and <code>api_client_secret</code> are used to connect to Benchling's SDK. For more information, see the Benchling API documentation.</li> <li>Required: The <code>internal_api_admin_email</code> and <code>internal_api_admin_password</code> are used to connect to Benchling's API for the migration service. This must be the email and password used to log in to an Admin account.</li> </ul> <p>The <code>CURRENT_REVISION_ID</code> variable is used to store the current state of where your Benchling tenant lies on the revision timeline. The id is the <code>revision_id</code> of the revision file that has been applied to your Benchling tenant.</p> <p>Tip</p> <p>If you have multiple Benchling tenants you'd like to synchronize, you can define multiple Benchling connections in the <code>env.py</code> file by creating multiple <code>BenchlingConnection</code> objects and respective <code>CURRENT_REVISION_ID</code> variables. Use the optional <code>current_revision_id_var_name</code> parameter to link the variable to the <code>BenchlingConnection</code> object.</p> </li> <li> <p>If your Benchling tenant has pre-existing schemas, run <code>liminal generate-files &lt;benchling_tenant&gt; [&lt;write_path&gt;]</code> to populate the root directory with your schema files from the given Benchling tenant. Your file structure should now look like this:</p> <pre><code>pizzahouse/\n    liminal/\n        env.py\n        versions/\n            &lt;revision_id&gt;_initial_init_revision.py\n    dropdowns/\n        ...\n    entity_schemas/\n        ...\n</code></pre> <p>Tip</p> <p>It is recommended to generate files using your production Benchling tenant. These schemas will be used as the single source of truth for your production tenant as well as other tenants you may have.</p> </li> <li> <p>Add your schema imports to the env.py file. For example:</p> <pre><code>from pizzahouse.dropdowns import *\nfrom pizzahouse.entity_schemas import *\n</code></pre> <p>Warning</p> <p>This is necessary for Liminal to recognize what schemas exist in your environment.</p> </li> <li> <p>Set up is complete! You're now ready to start using your schemas defined in code as the single source of truth for your Benchling tenant(s).</p> </li> </ol>"},{"location":"getting-started/tutorials/","title":"Tutorials","text":"<p>\ud83d\udea7 Video tutorial coming soon! Come back 11.8.2024 \ud83d\udea7</p>"},{"location":"reference/benchling-connection/","title":"Benchling connection","text":""},{"location":"reference/benchling-connection/#benchlingconnection-class","title":"BenchlingConnection: class","text":"<p>The <code>BenchlingConnection</code> class is used to define the connection information for a particular Benchling tenant. The BenchlingConnection class is defined in your <code>env.py</code> file and it also used to create a BenchlingService object. In the <code>env.py</code> file, the api_client and internal_api parameters are required for the BenchlingConnection object in orderto be used in the migration service. The BenchlingService can be imported from the liminal pacakage and be used to connect to Benchling's SDK, internal API, and/or Postgres warehouse.</p> <pre><code># Example BenchlingConnection definition\nfrom liminal.connection import BenchlingConnection\n\nPROD_CURRENT_REVISION_ID = \"12b31776a755b\"\n\n# It is highly recommended to use a secrets manager to store your credentials.\nconnection = BenchlingConnection(\n    tenant_name=\"pizzahouse-prod\",\n    tenant_alias=\"prod\",\n    current_revision_id_var_name=\"PROD_CURRENT_REVISION_ID\",\n    api_client_id=\"my-secret-api-client-id\",\n    api_client_secret=\"my-secret-api-client-secret\",\n    warehouse_connection_string=\"my-warehouse-connection-string\",\n    internal_api_admin_email=\"my-secret-internal-api-admin-email\",\n    internal_api_admin_password=\"my-secret-internal-api-admin-password\",\n)\n</code></pre>"},{"location":"reference/benchling-connection/#parameters","title":"Parameters","text":"<p>tenant_name: str</p> <p>The name of the tenant. ex: {tenant_name}.benchling.com</p> <p>tenant_alias: Optional[str] = None</p> <p>The alias of the tenant name. This is optional and is used as an alternate value when using the Liminal CLI</p> <p>current_revision_id_var_name: str = \"\"</p> <p>The name of the variable that contains the current revision id. If not provided, a derived name will be generated based on the tenant name/alias. Ex: {tenant_alias}_CURRENT_REVISION_ID or {tenant_name}_CURRENT_REVISION_ID if alias is not provided.</p> <p>api_client_id: Optional[str] = None</p> <p>The id of the API client.</p> <p>api_client_secret: Optional[str] = None</p> <p>The secret of the API client.</p> <p>warehouse_connection_string: Optional[str] = None</p> <p>The connection string for the warehouse.</p> <p>internal_api_admin_email: Optional[str] = None</p> <p>The email of the internal API admin.</p> <p>internal_api_admin_password: Optional[str] = None</p> <p>The password of the internal API admin.</p>"},{"location":"reference/benchling-session/","title":"Benchling session","text":""},{"location":"reference/benchling-session/#benchlingservice-class","title":"BenchlingService: class","text":"<p>The BenchlingService class takes in a BenchlingConnection object and is used to directly interact with Benchling's SDK, internal API, and Postgres warehouse. This class is surfaced for users so that there is one standard interface for interacting with Benchling around your codebase. Liminal's BenchlingService handles all session management and is a subclass of Benchling's SDK, so all functionality of Benchling's SDK is available.</p> <p>BenchlingService can be used to build on top of Liminal's ORM. Below is an example of how to use the BenchlingService class.</p> <pre><code>from liminal.connection import BenchlingConnection\nfrom liminal.connection import BenchlingService\n\nconnection = BenchlingConnection(\n    ...\n)\nbenchling_service = BenchlingService(connection, use_internal_api=True, use_warehouse=True) # enable all connections\n\n# Use Benchling SDK\nentity = benchling_service.custom_entities.get_by_id(\"my-entity-id\")\n\n# Use to query Postgres warehouse using SQLAlchemy\nwith benchling_service() as session:\n    entity = session.query(Pizza).all()\n</code></pre>"},{"location":"reference/benchling-session/#parameters","title":"Parameters","text":"<p>connection: BenchlingConnection</p> <p>The connection object that contains the credentials for the Benchling tenant.</p> <p>use_api: bool</p> <p>Whether to connect to the Benchling SDK. Defaults to True. (See Benchling SDK documentation here)</p> <p>use_internal_api: bool</p> <p>Whether to connect to the Benchling internal API. Defaults to False.</p> <p>use_warehouse: bool</p> <p>Whether to connect to the Benchling Postgres warehouse. Defaults to False. See SQLAlchemy documentation here for more information.</p>"},{"location":"reference/dropdowns/","title":"Dropdowns","text":""},{"location":"reference/dropdowns/#dropdown-schema-class","title":"Dropdown Schema: class","text":"<p>Below is an example of a dropdown schema defined in code. The <code>__benchling_name__</code> property is used to define the name of the dropdown in Benchling, while the <code>__allowed_values__</code> property is used to define the values of the dropdown.</p> <pre><code># Example dropdown definition\nfrom liminal.base.base_dropdown import BaseDropdown\n\n\nclass Toppings(BaseDropdown):\n    __benchling_name__ = \"Toppings\"\n    __allowed_values__ = [\"Pepperoni\", \"Mushroom\", \"Onion\", \"Sausage\", \"Bacon\"]\n</code></pre>"},{"location":"reference/dropdowns/#parameters","title":"Parameters","text":"<p>benchling_name: str</p> <p>The name of the dropdown in Benchling. There can be no duplicate dropdown names in Benchling.</p> <p>allowed_values: list[str]</p> <p>The list of values for the dropdown. Order matters and reflects the order of the dropdown in Benchling. Values must be unique.</p>"},{"location":"reference/entity-schemas/","title":"Entity schemas","text":""},{"location":"reference/entity-schemas/#entity-schema-class","title":"Entity Schema: class","text":"<p>Below is an example of a custom entity schema defined in code. All Liminal entity schema classes inherit from Liminal's BaseModel and uses SQLAlchemy behind the scenes to create an ORM. Liminal provides base classes and clear abstractions to an easy and standardized way to define entity schemas in code. However, you are still able to use raw SQLAlchemy to interact with the schemas when necessary.</p> <p>The properties defined in the <code>SchemaProperties</code> object and for <code>Column</code> objects align with the properties shown on the Benchling website. This is how Liminal defines your Benchling entity schema in code. Any of these properties can be manipulated to change the definition of the entity schema. Updates to the schema or the addition/archival of schemas are automatically detected by Liminal's migration service, which is run using the <code>liminal autogenerate</code> command. Refer to the First Migration page to run your first migration.</p> <p>Below, we will go through the different components of defining an entity schema class.</p> <pre><code>from liminal.orm.relationship import single_relationship\nfrom liminal.orm.schema_properties import SchemaProperties\nfrom liminal.orm.column import Column\nfrom liminal.validation import BenchlingValidator\nfrom liminal.enums import BenchlingEntityType, BenchlingFieldType, BenchlingNamingStrategy\nfrom sqlalchemy.orm import Query, Session\nfrom liminal.orm.mixins import CustomEntityMixin\nfrom liminal.orm.base_model import BaseModel\nfrom pizzahouse.dropdowns import Toppings\n\nclass Pizza(BaseModel, CustomEntityMixin):\n    __schema_properties__ = SchemaProperties(\n        name=\"Pizza\",\n        warehouse_name=\"pizza\",\n        prefix=\"PI\",\n        entity_type=BenchlingEntityType.CUSTOM_ENTITY,\n        naming_strategies={\n            BenchlingNamingStrategy.REPLACE_NAME_WITH_ID,\n            BenchlingNamingStrategy.IDS_FROM_NAMES,\n            BenchlingNamingStrategy.NEW_IDS,\n        },\n        mixture_schema_config=None,\n    )\n\n    dough = Column(name=\"dough\", type=BenchlingFieldType.ENTITY_LINK, required=True, entity_link=\"dough\")\n    cook_temp = Column(name=\"cook_temp\", type=BenchlingFieldType.INTEGER, required=False)\n    cook_time = Column(name=\"cook_time\", type=BenchlingFieldType.INTEGER, required=False)\n    toppings = Column(name=\"toppings\", type=BenchlingFieldType.DROPDOWN, required=False, dropdown=Toppings)\n    customer_review = Column(name=\"customer_review\", type=BenchlingFieldType.INTEGER, required=False)\n    slices = Column(name=\"slices\", type=BenchlingFieldType.ENTITY_LINK, required=False, is_multi=True, entity_link=\"slice\")\n\n    dough_entity = single_relationship(\"Dough\", dough)\n    slice_entities = multi_relationship(\"Slice\", \"Pizza\", \"slices\")\n\n    def __init__(\n        self,\n        dough: str,\n        cook_temp: int | None = None,\n        cook_time: int | None = None,\n        customer_review: int | None = None,\n    ):\n        self.dough = dough\n        self.cook_temp = cook_temp\n        self.cook_time = cook_time\n        self.customer_review = customer_review\n\n\n    @classmethod\n    def query(self, session: Session) -&gt; Query:\n        return session.query(Pizza)\n\n    def get_validators(self) -&gt; list[BenchlingValidator]:\n        return []\n</code></pre>"},{"location":"reference/entity-schemas/#mixins-class","title":"Mixins: class","text":"<p>All Liminal entity schema classes must inherit from one of the mixins in the mixins module. The mixin provides the base columns for the specific entity schema type. For example, the <code>CustomEntityMixin</code> provides the base columns for a custom entity schema. To learn more, check out the SQLAlchemy documentation here.</p>"},{"location":"reference/entity-schemas/#schema-properties-class","title":"Schema Properties: class","text":""},{"location":"reference/entity-schemas/#parameters","title":"Parameters","text":"<p>name: str</p> <p>The name of the entity schema. Must be unique across all entity schemas.</p> <p>warehouse_name: str</p> <p>The warehouse name of the entity schema. Must be unique across all entity schemas.</p> <p>Note</p> <p>The warehouse names are used as keys across liminal and are used as entity_link values in Columns.</p> <p>Warning</p> <p>If warehouse access is not enabled on your tenant, you will be unable to update the warehouse name.</p> <p>Liminal assumes the Benchling generated warehouse name to be <code>to_snake_case(name)</code>.</p> <p>prefix: str</p> <p>The prefix of the entity schema. Must be unique across all entity schemas.</p> <p>entity_type: BenchlingEntityType</p> <p>The type of entity schema. Type must be one of the values from the BenchlingEntityType enum.</p> <p>naming_strategies: set[BenchlingNamingStrategy]</p> <p>The naming strategies for the entity schema. Must be a set of values from the BenchlingNamingStrategy enum.</p> <p>mixture_schema_config: MixtureSchemaConfig | None</p> <p>The mixture schema configuration for the entity schema. Must be defined as a MixtureSchemaConfig object.</p>"},{"location":"reference/entity-schemas/#column-class","title":"Column: class","text":"<p>Warning</p> <p>If warehouse access is not enabled on your tenant, you will be unable to update the warehouse name for fields.</p> <p>Liminal will enforce that the column variable name (which represents the warehouse name) matches the Benchling generated warehouse name, which Liminal assumes to be <code>to_snake_case(name)</code>.</p>"},{"location":"reference/entity-schemas/#parameters_1","title":"Parameters","text":"<p>name: str</p> <p>The external facing name of the column.</p> <p>type: BenchlingFieldType</p> <p>The type of the field. Type must be one of the values from the BenchlingFieldType enum.</p> <p>required: bool</p> <p>Whether the field is required.</p> <p>is_multi: bool = False</p> <p>Whether the field is a multi-value field. Defaults to False.</p> <p>parent_link: bool = False</p> <p>Whether the field is a parent link field. Defaults to False.</p> <p>dropdown: Type[BaseDropdown] | None = None</p> <p>The dropdown object for the field. The dropdown object must inherit from BaseDropdown and the type of the Column must be <code>BenchlingFieldType.DROPDOWN</code>. Defaults to None.</p> <p>entity_link: str | None = None</p> <p>The entity link for the field. The entity link must be the <code>warehouse_name</code> as a string of the entity schema that the field is linking to. The type of the Column must be <code>BenchlingFieldType.ENTITY_LINK</code> in order to be valid. Defaults to None.</p> <p>tooltip: str | None = None</p> <p>The tooltip for the field. Defaults to None.</p>"},{"location":"reference/entity-schemas/#relationships-module","title":"Relationships: module","text":"<p>If there are columns that are entity links, that means the value of the column is the linked entity id or ids. You can easily define relationships using Liminal's wrapper functions around SQLAlchemy. The two relationships to define are <code>single_relationship</code> and <code>multi_relationship</code>, and examples are shown above.</p> <pre><code># single_relationship is used for a non-multi field where there is a one-to-one relationship from the current class to the target class.\nsingle_relationship(target_class_name: str, entity_link_field: Column, backref: str | None = None) -&gt; RelationshipProperty:\n\n# multi_relationship is used for a multi field where there is a \"one-to-many\" relationship from the current class to the target class.\n# NOTE: This is not a normal one-to-many relationship. The multi field is represented as a list of entity ids.\nmulti_relationship(target_class_name: str, current_class_name: str, entity_link_field_name: str) -&gt; RelationshipProperty\n</code></pre> <p>How do I access the joined entity or entities?</p> <pre><code>connection = BenchlingConnection(...)\nbenchling_service = BenchlingService(connection, use_db=True)\n\nwith benchling_service as session:\n    pizza_entity = session.query(Pizza).first()\n\n    # NOTE: Accessing the relationship entities must be done within the session context.\n    dough = pizza_entity.dough_entity\n    slices = pizza_entity.slice_entities\n</code></pre>"},{"location":"reference/entity-schemas/#custom-query","title":"Custom Query","text":"<p>The <code>query()</code> method must be implemented for the entity schema class to define a custom query. This is useful if you want to add additional filtering or joins to the query.</p>"},{"location":"reference/entity-schemas/#validators-class","title":"Validators: class","text":"<p>As seen in the example above, the <code>get_validators</code> method is used to define a list of validators for the entity schema. These validators run on entities of the schema that are queried from Benchling's Postgres database. For example:</p> <pre><code>pizza_entity = Pizza.query(session).first()\n\n# Validate a single entity from a query\nreport = CookTempValidator().validate(pizza_entity)\n\n# Validate all entities for a schema\nreports = Pizza.validate(session)\n</code></pre> <p>The list of validators within <code>get_validators</code> are used to run on all entities of the schema.</p> <p>The <code>BenchlingValidator</code> object is used to define the validator classes, that can be defined with custom logic to validate entities of a schema. Refer to the Validators page to learn more about how to define validators.</p>"},{"location":"reference/entity-schemas/#additional-functionality","title":"Additional Functionality","text":"<p>Below is additional functionality that is provided by the Liminal BaseModel class.</p> <pre><code>connection = BenchlingConnection(...)\nbenchling_service = BenchlingService(connection, use_db=True)\n\nwith benchling_service as session:\n\n    # Get all entities for a schema and return a dataframe\n    df = Pizza.df(session)\n\n    # Validate all entities for a schema and return a list of ValidatorReports\n    reports = Pizza.validate(session)\n\n    # Validate all entities for a schema and return a dataframe\n    validated_df = Pizza.validate_to_df(session)\n</code></pre>"},{"location":"reference/entity-schemas/#notes","title":"Notes","text":"<ul> <li>Note that the Entity Schema definition in Liminal does not cover 100% of the properties that can be set through the Benchling website. However, the goal is to have 100% parity! If you find any missing properties that are not covered in the definition or migration service, please open an issue on Github. In the meantime, you can manually set the properties through the Benchling website.</li> </ul>"},{"location":"reference/operations/","title":"Operations","text":""},{"location":"reference/operations/#operations-class","title":"Operations: class","text":"<p>Operations are the building blocks of a revision file. They represent a singular API call that does a specific action to change the Benchling model. They are generated by the <code>liminal autogenerate</code> command in the upgrade/downgrade functions of a revision file and can also be created manually. Operations are used to create, update, and archive entity schemas, dropdowns, and entity schema fields (a full list of operations can be found below). Operations have a couple of common functionalities:</p> <pre><code># Defines the operation for archiving the 'dough' field on the 'pizza' entity schema\nexample_operation = ArchiveEntitySchemaField('pizza', 'dough')\n\n# Executes the operation. This will run an action using the Benchling API to execute a change. In this case, it will archive the 'dough' field on the 'pizza' entity schema.\nexample_operation.execute()\n\n# Returns a description of what the operation will do.\n# Ex: 'pizza: Archiving entity schema field 'dough'.'\nexample_operation.describe_operation()\n\n# Returns a description of the current state of the operation.\n# Ex: 'pizza: Entity schema field 'dough' is defined in Benchling but not in code.'\nexample_operation.describe()\n\n# Validates the operation. Note: Not all operations have a validate() method.\nexample_operation.validate()\n</code></pre>"},{"location":"reference/operations/#dropdown-operations","title":"Dropdown Operations","text":"Operation Class Description CreateDropdown Creates a new dropdown with specified options. ArchiveDropdown Archives an existing dropdown. UnarchiveDropdown Unarchives an archived dropdown. UpdateDropdownName Updates the name of an existing dropdown. CreateDropdownOption Creates a new option in an existing dropdown. ArchiveDropdownOption Archives an existing option in a dropdown. UpdateDropdownOption Updates the name of an existing option in a dropdown. ReorderDropdownOptions Reorders the options in an existing dropdown."},{"location":"reference/operations/#entity-schema-operations","title":"Entity Schema Operations","text":"Operation Class Description CreateEntitySchema Creates a new entity schema with specified fields. UpdateEntitySchema Updates the properties of an existing entity schema. ArchiveEntitySchema Archives an existing entity schema. UnarchiveEntitySchema Unarchives an archived entity schema. CreateEntitySchemaField Creates a new field in an existing entity schema. UpdateEntitySchemaField Updates the properties of an existing field in an entity schema. ArchiveEntitySchemaField Archives an existing field in an entity schema. UnarchiveEntitySchemaField Unarchives an archived field in an entity schema. ReorderEntitySchemaFields Reorders the fields in an existing entity schema."},{"location":"reference/revision-file/","title":"Revision file","text":""},{"location":"reference/revision-file/#example-revision-file","title":"Example Revision File","text":"<p>Below is an example of a revision file that gets generated by the <code>liminal autogenerate</code> command. This flow was heavily inspired by the Alembic migration workflow. When <code>liminal upgrade</code> is run, the operations in the <code>upgrade()</code> function are executed and when <code>liminal downgrade</code> is run, the operations in the <code>downgrade()</code> function are executed. Each revision is linearly linked to a previous revision, creating a timeline of revisions/operations. This allows for the user to traverse the history of their Benchling model.</p> <pre><code>'''\ntest\n\nRevision ID: c3a9cd009713\nRevises: d28335bffaba\nCreate Date: 2024-10-26 10:33:26.390965\n'''\n\nimport liminal.external as b\n\n# revision identifiers, used by Liminal.\nrevision = \"c3a9cd009713\"\ndown_revision = \"d28335bffaba\"\n\n\n# ### commands auto generated by Liminal - please review (and adjust if needed)! ###\ndef upgrade() -&gt; list[b.BaseOperation]:\n    return [b.ArchiveEntitySchemaField('pizza', 'dough')]\n\n# ### commands auto generated by Liminal - please review (and adjust if needed)! ###\ndef downgrade() -&gt; list[b.BaseOperation]:\n    return [b.UnarchiveEntitySchemaField('pizza', 'dough')]\n</code></pre> <p>Warning</p> <p>Generated revision files cannot detect changes to changes in warehouse names. In order to resolve this, you must manually edit the revision file.</p> <p>Updating Entity Schema warehouse name: <pre><code>b.UpdateEntitySchema('old_warehouse_name', \n    b.BaseSchemaProperties(warehouse_name='new_warehouse_name')\n)\n</code></pre></p> <p>Updating Entity Schema Field warehouse name: <pre><code>b.UpdateEntitySchemaField('entity_schema_warehouse_name', 'field_warehouse_name', \nb.BaseFieldProperties(warehouse_name='new_warehouse_name')\n)\n</code></pre></p> <p>Updating Dropdown warehouse name: <pre><code>b.UpdateDropdown('old_warehouse_name', \n    b.BaseDropdownProperties(warehouse_name='new_warehouse_name')\n)\n</code></pre></p>"},{"location":"reference/validators/","title":"Validators","text":""},{"location":"reference/validators/#benchling-base-validator-class","title":"Benchling Base Validator: class","text":"<p>Below is an example of a Benchling Validator defined in Liminal for validating the cook temp of a pizza.</p> <pre><code>from liminal.validation import BenchlingValidator, BenchlingValidatorReport, BenchlingReportLevel\nfrom liminal.orm.base_model import BaseModel\n\nclass CookTempValidator(BenchlingValidator):\n    \"\"\"Validates that a field value is a valid enum value for a Benchling entity\"\"\"\n\n    def validate(self, entity: type[BaseModel]) -&gt; BenchlingValidatorReport:\n        valid = True\n        message = None\n        if entity.cook_time is not None and entity.cook_temp is None:\n            valid = False\n            message = \"Cook temp is required if cook time is set\"\n        if entity.cook_time is None and entity.cook_temp is not None:\n            valid = False\n            message = \"Cook time is required if cook temp is set\"\n        return self.create_report(valid, BenchlingReportLevel.MED, entity, message)\n</code></pre> <p>A <code>validate(entity)</code> function is required to be defined in the BenchlingValidator subclass. This function should contain the logic to validate the entity. The function should return a <code>BenchlingValidatorReport</code> object, which can be easily created using the <code>create_report</code> method.</p>"}]}