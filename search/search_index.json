{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Liminal ORM","text":""},{"location":"#overview","title":"Overview","text":"<p>Liminal ORM<sup>1</sup> is an open-source Python package that builds on Benchling's LIMS<sup>2</sup> platform and provides a simple, code-first approach for synchronizing and managing your Benchling schemas. Join our Slack community here!</p> <p>Liminal provides an ORM framework using SQLAlchemy along with a schema migration service inspired by Alembic. This allows you to define your Benchling schemas in code and create a single source of truth that synchronizes between your upstream Benchling tenant(s) and downstream dependencies. By creating a standard interface and through using one-line CLI<sup>3</sup> commands, Liminal enables a code-first approach for managing Benchling tenants and accessing Benchling data. With the schemas defined in code, you can also take advantage of the additional capabilities that the Liminal toolkit provides. This includes:</p> <ul> <li>The ability to run migrations to your Benchling tenant(s) through an easy to use CLI.</li> <li>Easy to implement validation rules to reflect business logic for all of your Benchling entities.</li> <li>Strongly typed queries for all your Benchling entities.</li> <li>CI/CD integration with GitHub Actions to ensure that your Benchling schemas and code are always in sync.</li> <li>And more based on community contributions/feedback :)</li> </ul> <p>Benchling is an industry standard cloud platform for life sciences R&amp;D. Liminal builds on top of Benchling's platform and assumes that you already have a Benchling tenant set up and have (or have access to) an admin user account. If not, learn more about getting started with Benchling here!</p> <p>If you are a Benchling user, try out Liminal by following the Quick Start Guide! Reach out in the Slack community (preferred method) with any questions or to simply introduce yourself! If there is something blocking you from using Liminal or you're having trouble setting Liminal up, please share in Issues or reach out directly (info below).</p> <p>Nirmit Damania is the creator and current maintainer of Liminal (I post Liminal updates to Discussions and my LinkedIn). Most importantly, you have the ability to influence the future of Liminal! Any feedback, positive or negative, is highly encouraged and will be used to steer the direction of Liminal. Refer to the Contributing guide to learn more about how you can contribute to Liminal.</p> <p>\u2b50\ufe0f Leave a star on the repo to spread the word! If you or your organization use Liminal, please consider adding yourself or your organization to the Users list.</p>"},{"location":"#mission","title":"Mission","text":"<p>The democratization of software in Biotech is crucial. By building a community around complex, yet common, problems and creating open-source solutions, we can work together to tackle these challenges together and enable faster innovation in the industry. By breaking down the silos between private platforms, we can enable a more dynamic and open ecosystem. This was the motivation for Liminal's creation. Liminal's goal is to create an open-source software product that enables a standard, code-first approach to configuration and change management for LIMS systems. We started with Benchling, but the goal is to make Liminal the go-to solution for any LIMS system.</p>"},{"location":"#direct-contact-information","title":"Direct contact information","text":"<ul> <li>Liminal Community Slack group: Join here</li> <li>Email: opensource@dynotx.com</li> <li>LinkedIn: Nirmit Damania</li> </ul>"},{"location":"#footnotes","title":"Footnotes","text":"<p>ORM<sup>1</sup>: Object-Relational Mapper. An ORM is a piece of software designed to translate between the data representations used by databases and those used in object-oriented programming. In this case, Liminal provides an ORM layer built specifically for Benchling that allows for users to quickly and easily define Benchling entities in code. SQLAlchemy is the underlying ORM that Liminal uses to interact with your Benchling tenant(s) and is an open-source software that is an industry standard software.</p> <p>LIMS<sup>2</sup>: Laboratory Information Management System. A LIMS is a piece of software that allows you to effectively manage samples and associated data. Benchling is an industry-leading LIMS software.</p> <p>CLI<sup>3</sup>: Command Line Interface. A CLI is a piece of software that allows you to interact with a software program via the command line. Liminal provides a CLI that allows you to interact with your Liminal environment. This project uses Typer to construct the CLI</p>"},{"location":"contributing/","title":"Contributing to Liminal ORM","text":"<p>Thank you in advance for your contribution to Liminal! A contribution of any kind has an impact on the community. Remember to star the repo on GitHub and share Liminal with your colleagues to grow our community!</p>"},{"location":"contributing/#ways-to-contribute","title":"Ways to Contribute","text":"<p>Everyone in the community has the ability to influence the roadmap of Liminal, no matter how big or small the contribution. Below are some ways you can contribute:</p> <ul> <li>Code Contribution: Help us improve the codebase by fixing bugs, adding new features, or improving documentation.</li> <li>Documentation: Help us improve the documentation by adding missing information, improving existing documentation, or raising an issue to update the documentation where needed.</li> <li>Raising an Issue: Report bugs, suggest features, or provide feedback to help us improve.</li> <li>Spread the Word: Leave a star on the repo in GitHub or spread the word with coworkers to help grow and cultivate the community.</li> <li>Add yourself as a User: If your project or organization uses Liminal, add yourself to USERS.md. This is a great way to help us prioritize Liminal's roadmap, and get first dibs on new features ;).</li> </ul>"},{"location":"contributing/#setup","title":"Setup","text":"<p>If you are interested in contributing to Liminal, please follow the steps below to setup the Liminal repository locally.</p> <ol> <li> <p>Fork the Liminal repository by clicking the \"Fork\" button on the top right corner of the repository page. Follow the instructions here: Fork a repo. After forking, sync your fork with the upstream repository to keep it up-to-date.</p> </li> <li> <p>Ensure your Python environment is setup correctly. We recommend using pyenv to manage python versions.</p> </li> <li> <p>Install Poetry</p> </li> </ol> <p>Use the Poetry Installation guide</p> <ol> <li> <p>Install Liminal dependencies</p> <p><code>poetry install --all-extras</code></p> </li> <li> <p>Ensure python version matches Liminal's supported version</p> <p>Supported python versions of Liminal can be found in pyproject.toml. We recommend using pyenv to manage python versions.</p> </li> <li> <p>Start developing :)</p> </li> </ol>"},{"location":"contributing/#development-cycle","title":"Development cycle","text":"<p>Liminal uses <code>pre-commit</code> hooks for enforcing formatting, linting, and mypy. Formatting and linting is done using <code>ruff</code> Every commit requires these to pass and you can run them manually using <code>pre-commit run</code> (use <code>-a</code> flag to run on all files). Commit with the <code>--no-verify</code> flag to avoid running the pre-commit hooks.</p> <p>Please include tests when adding new functionality. Liminal uses <code>pytest</code> for testing. Run this using <code>pytest liminal/</code> to run all tests. All tests must pass in order to merge in a Pull Request.</p> <p>If making changes to the documentation (which is created using <code>MKDocs-material</code>). Locally host and get a live preview of the website using <code>mkdocs serve</code>.</p>"},{"location":"contributing/#making-a-pull-request","title":"Making a Pull Request","text":"<p>Contributions to the codebase must be made by submitting a Pull Request through your forked repository.</p>"},{"location":"future-direction/","title":"Future direction","text":"<p>Please check the Issues page for the latest updates on what's coming in the near future!</p>"},{"location":"future-direction/#roadmap","title":"Roadmap","text":"<p>This roadmap is based on community feedback. If there is a feature or something blocking you from using Liminal, please reach out to me and it will help me prioritize the Liminal roadmap!</p> <ul> <li>Achieve 100% parity with Entity Schemas (Done! \u2705)<ul> <li>Name template</li> <li>Inventory settings</li> </ul> </li> <li>Expand coverage to all Benchling schema types<ul> <li>Registry schemas (In progress \ud83d\udea7)</li> <li>Container schema</li> <li>Box schema</li> <li>Plate schema</li> <li>Location schema</li> </ul> </li> <li>Liminal automatically generates user-friendly validation reports (In progress \ud83d\udea7)</li> <li>Make validators on entity schemas labeled as decorators (Done! \u2705)</li> </ul> <p>The grand vision of Liminal is to expand its coverage to other LIMS systems. Liminal could become a community driven product that standarizes a code-first approach to interact with different LIMS systems. This would become a terraform-like product that allows mapping between different LIMS systems and allows users to control and define how they want to interact with their LIMS systems.</p>"},{"location":"release-notes/","title":"Release notes","text":"<p>For full release notes, please visit the GitHub Releases page. Release versions follow semantic versioning. This page will document migration steps needed for major and minor version changes.</p>"},{"location":"release-notes/#v200","title":"v2.0.0","text":""},{"location":"release-notes/#upgrade-steps","title":"Upgrade Steps","text":"<ul> <li>PR #88: adds ability to defined name templates for entity schemas</li> <li>PR #84: adds ability to define chip naming for entity schemas</li> <li>PR #82: adds ability to define constraints for entity schemas.<ul> <li>The above PRs brings achieves 100% parity with Entity Schemas in Benchling. The guidance for migrating to v2.0.0 is to regenerate your schemas defined in code using <code>liminal generate-files &lt;benchling_tenant&gt; [&lt;write_path&gt;]</code>. This will recreate your dropdown/schema files, this time with the new properties covered by Liminal.</li> </ul> </li> <li>PR #68: refactors how validators are done in Liminal using a decorator pattern. Refer to the validators page for full details on implementation.<ul> <li>If you don't have validators defined, no action is needed! Otherwise, you will need to manually refactor your validators to use the new pattern.</li> </ul> </li> </ul>"},{"location":"release-notes/#v110","title":"v1.1.0","text":""},{"location":"release-notes/#upgrade-steps_1","title":"Upgrade Steps","text":"<ul> <li>PR #64: makes query function optional in schema classes.<ul> <li>Remove query functions from schema classes, unless you have custom logic.</li> </ul> </li> <li>PR #72: block warehouse name changes to operations.<ul> <li>BenchlingConnetion now takes in <code>warehouse_access</code> parameter. If you do not have warehouse access on your Benchling tenant, set this to <code>False</code>.</li> </ul> </li> <li> <p>PR #53: move field wh name to base field props.</p> <ul> <li>Update historical revision files with changed operation signatures.</li> </ul> <pre><code># Replace UpdateEntitySchemaName with...\nUpdateEntitySchema('old_warehouse_name', \n    BaseSchemaProperties(warehouse_name='new_warehouse_name'))\n\n# Replace UpdateEntitySchemaFieldName with...\nUpdateEntitySchemaField('entity_schema_warehouse_name', \n    'field_warehouse_name', \n    BaseFieldProperties(warehouse_name='new_warehouse_name'))\n\n# CreateEntitySchemaField no longer takes wh_field_name as a parameter. \n# Now gets passed in via BaseFieldProperties.\nCreateEntitySchemaField('entity_schema_warehouse_name', \n    BaseFieldProperties(warehouse_name='new_warehouse_name', ...))\n\n# CreateEntitySchema takes in a list of fields instead of dict[str, Benchling FieldProperties]\nCreateEntitySchema(BaseSchemaProperties(...), [BaseFieldProperties(...), ...])\n</code></pre> </li> <li> <p>PR #63: numpy and pandas version tightening.</p> <ul> <li>numpy = \u201c^1.23.5\u201d</li> <li>pandas = \"&gt;=1.5.3\" --&gt; \u201c^1.5.3\"</li> </ul> </li> </ul>"},{"location":"blog/dynotx-recommended-sop/","title":"DynoTx Recommended SOP","text":"<p>Below, you will find the SOP Dyno Therapeutics follows for using Liminal to manage their Benchling schemas. This SOP assumes that you have already set up Liminal.</p>"},{"location":"blog/dynotx-recommended-sop/#dyno-therapeutics-benchling-change-management-sop","title":"Dyno Therapeutics Benchling Change Management SOP","text":"<p>Written: 07.24.2024 Author: Nirmit Damania</p> <p>Dyno's Benchling tenants are set up as a Dev, Test, and Prod environments. All scientists and a select number of engineers have access to the PROD tenant, and all work is done in PROD. The Dev and Test tenants are used for development and testing of new features before merging into PROD. Liminal is used to keep the Test and Prod tenants in sync, while Dev is used for development/testing. Dyno uses a ticketing system through a Slack channel for Benchling schema change requests. The Benchling Admin is responsible for managing the Benchling environment and implementing the requested changes.</p> <p>Let's say a change has to be made to a Benchling schema...</p>"},{"location":"blog/dynotx-recommended-sop/#pre-work","title":"Pre-work","text":"<ol> <li> <p>If the change is non-trivial, the Benchling Admin will modify the Liminal schemas in the Dev tenant on the Benchling UI. This allows them to try changes and iterate in a safe environment until the final changes are settled.</p> </li> <li> <p>Once they are confident in the exact changes needed to be made to the Liminal schemas, they move onto the migration step. As a safeguard, Liminal offers the ability to revert back to the original state automatically.</p> </li> </ol>"},{"location":"blog/dynotx-recommended-sop/#migration","title":"Migration","text":"<ol> <li> <p>Make change(s) to the Liminal schemas in code.</p> </li> <li> <p>Run <code>liminal autogenerate PROD 'description'</code>. This will generate a revision file, and create a list of operations to migrate PROD to be in sync with the schemas defined in code.</p> <p>Why point to PROD?</p> <p>The PROD tenant is the tenant that users interact with, meaning it should always be in sync with the code. This means when we autogenerate against PROD, we are comparing the Liminal schemas in code against the actual Benchling schemas in PROD. <code>autogenerate</code> creates a diff (a computed difference) and generates a list of operations for what needs to be done to make the PROD tenant match the Liminal schemas in code.</p> </li> <li> <p>Create a PR in GitHub with schema changes and revision file.</p> </li> <li> <p>Run <code>liminal upgrade TEST</code>. Dyno keeps TEST in sync with PROD, for easy testing of new features. This runs the generated list of operations in the generated revision file against the TEST tenant.</p> </li> <li> <p>Review the changes in TEST.</p> </li> <li> <p>If the changes look good, run <code>liminal upgrade PROD</code>. This will apply the operations to the PROD tenant.</p> </li> <li> <p>Add screenshots of successful migration to the PR.</p> </li> <li> <p>Merge the PR.</p> </li> </ol>"},{"location":"blog/dynotx-recommended-sop/#reverting-tenant-to-the-current-state","title":"Reverting Tenant to the current state","text":"<p>Let's say you are making some changes in the DEV tenant, but you need to revert back to the current state of your schemas defined in code. Liminal offers a way to quickly migrate the tenant back/forward to the current state.</p> <ol> <li> <p>Run <code>liminal autogenerate TEST 'description'</code>. This will generate a revision file, and create a list of operations to migrate TEST to be in sync with the schemas defined in code.</p> </li> <li> <p>Run <code>liminal upgrade TEST</code>. This will apply the operations to the TEST tenant.</p> </li> <li> <p>Delete the revision file created in step 1.</p> </li> </ol> <p>Why delete the revision file?</p> <p>Liminal only keeps of 1 linear history of changes. This \"cleanup\" migration is not part of the linear history, so it should be deleted.</p>"},{"location":"getting-started/downgrading/","title":"Downgrading","text":"<ol> <li> <p>Let's say you want to revert changes made to your Benchling tenant. You can do this by downgrading to a previous revision. This will run the downgrade operations defined in the revision file and revert the tenant back to the previous state. This is a useful tool to revert accidental changes made to your Benchling tenant and maintain the history of your schema changes.</p> </li> <li> <p>In your CLI in Liminal's root directory (that contains the <code>liminal/</code> path), run the following command:</p> <pre><code>liminal downgrade &lt;benchling_tenant_name&gt; &lt;downgrade_descriptor&gt;\n</code></pre> <p>The downgrade descriptor</p> <p>The downgrade descriptor can be one of:</p> <ul> <li><code>revision_id</code>: The ID of the revision to downgrade to. Ex: <code>\"d28335bffaba\"</code></li> <li><code>-&lt;n&gt;</code>: The <code>n</code> revisions before the current revision. Ex: <code>-1</code> will downgrade to the revision before the current revision.</li> </ul> </li> </ol>"},{"location":"getting-started/first-migration/","title":"First migration","text":"<ol> <li> <p>You have changes you need to make to your Benchling schema model. Manipulate your schema classes defined in code and make changes where needed. When you are finished, you are ready to run your first migration!</p> <p>Manipulating schemas</p> <p>For an overview of what is covered by Liminal and can be defined in code, please see the Reference section to get detailed documentation on the different class properties. When making changes, anything that Liminal covers should be manipulated in code. Otherwise, your schemas defined in code will become out of sync with your Benchling tenant. Any properties that Liminal does not cover should be manipulated through the Benchling UI, as Liminal cannot track changes to these properties.</p> </li> <li> <p>In your CLI in Liminal's root directory (that contains the <code>liminal/</code> path), run the following command:</p> <pre><code>liminal upgrade &lt;benchling_tenant_name&gt; &lt;upgrade_descriptor&gt;\n</code></pre> <p>Example: <code>liminal upgrade prod \"remove dough column from pizza schema\"</code>.</p> <p>This will automatically generate a new revision file in the <code>versions/</code> directory. This revision file defines the set of steps (or \"operations\") that will be needed to make the targeted Benchling tenant up to date with the changes made in the schema model.</p> <p>If I have multiple Benchling tenants, do I have to run <code>autogenerate</code> for each tenant?</p> <p>No, Liminal only keeps a single thread of revision history so that each revision file has a linear link. In the case of multiple tenants that need to stay in sync together, we recommend pointing <code>autogenerate</code> at your production tenant, or the tenant that acts as the production environment. This will ensure there is a consistent history that your other tenants can follow. When ready, you can then apply the revision to all your tenants.</p> </li> <li> <p>Review the generated revision file and set of operations to ensure that it is accurate.</p> </li> </ol> <p>### Example Revision File</p> <pre><code>```python\nimport liminal.external as b\n\n# revision identifiers, used by Liminal.\nrevision = \"c3a9cd009713\"\ndown_revision = \"d28335bffaba\"\n\n\n# ### commands auto generated by Liminal - please review (and adjust if needed)! ###\ndef upgrade() -&gt; list[b.BaseOperation]:\n    return [b.ArchiveEntitySchemaField('pizza', 'dough')]\n\n# ### commands auto generated by Liminal - please review (and adjust if needed)! ###\ndef downgrade() -&gt; list[b.BaseOperation]:\n    return [b.UnarchiveEntitySchemaField('pizza', 'dough')]\n```\n\nThis looks correct! I wanted to archive the `dough` column from the `pizza` entity schema.\n</code></pre> <ol> <li> <p>Once you've reviewed the revision file and are ready to apply the changes, run the following command:</p> <pre><code>liminal upgrade &lt;benchling_tenant_name&gt; &lt;upgrade_descriptor&gt;\n</code></pre> <p>The upgrade descriptor</p> <p>The upgrade descriptor can be one of:</p> <ul> <li><code>head</code> to upgrade to the latest revision.</li> <li><code>revision_ID</code> to upgrade to a specific revision. Ex: <code>\"c3a9cd009713\"</code></li> <li><code>+&lt;n&gt;</code> to upgrade to the revision <code>n</code> revisions after the current revision. Ex: <code>\"+1\"</code> will upgrade to the revision after the current revision.</li> </ul> <p>In this case, we run <code>liminal upgrade prod head</code> to upgrade to apply the revision to the production tenant.</p> <p>Tip</p> <p>If you have multiple Benchling tenants, you can run <code>liminal upgrade</code> multiple times pointing to different tenants to upgrade them. It is recommended to run against your test tenant first to ensure the changes are applied as expected.</p> </li> <li> <p>You should see output indicating that the revision was applied successfully. Check your Benchling tenant to ensure the changes were applied as expected!</p> </li> </ol> <p>Warning</p> <p>If the migration fails mid way through, do not attempt to run the full upgrade again. This will re-run the same operations that were already run which is unsafe. Instead, you can comment out the operations that have already been run in the <code>upgrade()</code> function and run <code>liminal upgrade</code> again. This will ensure that only the operations that have not yet been run get applied. Alternatively, you can comment out the mirrored operations not run yet in the <code>downgrade()</code> function and run <code>liminal downgrade</code> to revert the changes so that you can try again. (More information on downgrades on the next page!)</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Install Liminal via pip:</p> <pre><code>pip install liminal-orm\n</code></pre> <p>Install Liminal via github:</p> <pre><code>python -m pip install git+https://github.com/dynotx/liminal-orm.git --ignore-installed\n</code></pre>"},{"location":"getting-started/prerequisites/","title":"Prerequisites","text":"<ol> <li> <p>Benchling Admin Account: Liminal builds on top of Benchling's LIMS system. You will need access and credentials to an admin account for your Benchling tenant(s). Liminal needs credentials with full admin priveleges in order to manipulate Benchling schemas through their API.</p> </li> <li> <p>SSO optional: A requirement for Liminal's migration service to work is for your Benchling tenant to have SSO optional or disabled. At the moment, a part of Liminal's API connection requires the admin email and password and is unable to be authenticated when SSO is required. You can message Benchling support to request that your tenant be configured to be SSO optional or disabled.</p> </li> <li> <p>Python: Liminal is built using Python. You will need Python 3.9 or later installed on your machine.</p> </li> </ol>"},{"location":"getting-started/prerequisites/#notes","title":"Notes","text":"<ul> <li>It is important to note that Liminal only supports coverage for Benchling entity schemas and dropdowns at the moment. We are currently working on expanding support to include all Benchling schema types (registry schemas next). Leave a comment on the Discussions forum on your vote for what should be supported next, or what is blocking you from using Liminal!</li> </ul>"},{"location":"getting-started/setup/","title":"Setup","text":"<ol> <li> <p><code>cd</code> into the directory where you want to instantiate your Liminal environment. This will be the root directory where your schemas will be defined. Note: the Liminal CLI must always be run from within this root directory.</p> </li> <li> <p>Run <code>liminal init</code> in your CLI to initialize your Liminal environment. This will create a <code>liminal/</code> directory that contains an <code>env.py</code> file and a <code>versions/</code> directory.</p> <ul> <li>The <code>env.py</code> file is used to store your Benchling connection information.</li> <li>The <code>versions/</code> directory is used to store your revision files.</li> </ul> </li> <li> <p>Populate the <code>env.py</code> file with your Benchling connection information, following the instructions in the file. For example:</p> <pre><code>from liminal.connection import BenchlingConnection\n\n    PROD_CURRENT_REVISION_ID = \"12b31776a755b\"\n\n    # It is highly recommended to use a secrets manager to store your credentials.\n    connection = BenchlingConnection(\n        tenant_name=\"pizzahouse-prod\",\n        tenant_alias=\"prod\",\n        current_revision_id_var_name=\"PROD_CURRENT_REVISION_ID\",\n        api_client_id=\"my-secret-api-client-id\",\n        api_client_secret=\"my-secret-api-client-secret\",\n        internal_api_admin_email=\"my-secret-internal-api-admin-email\",\n        internal_api_admin_password=\"my-secret-internal-api-admin-password\",\n)\n</code></pre> <ul> <li>Required: The <code>api_client_id</code> and <code>api_client_secret</code> are used to connect to Benchling's SDK. For more information, see the Benchling API documentation.</li> <li>Required: The <code>internal_api_admin_email</code> and <code>internal_api_admin_password</code> are used to connect to Benchling's API for the migration service. This must be the email and password used to log in to an Admin account.</li> </ul> <p>The <code>CURRENT_REVISION_ID</code> variable is used to store the current state of where your Benchling tenant lies on the revision timeline. The id is the <code>revision_id</code> of the revision file that has been applied to your Benchling tenant.</p> <p>Tip</p> <p>If you have multiple Benchling tenants you'd like to synchronize, you can define multiple Benchling connections in the <code>env.py</code> file by creating multiple <code>BenchlingConnection</code> objects and respective <code>CURRENT_REVISION_ID</code> variables.</p> </li> <li> <p>If your Benchling tenant has pre-existing schemas, run <code>liminal generate-files &lt;benchling_tenant_name&gt; [&lt;write_path&gt;]</code> to populate the root directory with your schema files from the given Benchling tenant. Your file structure should now look like this:</p> <pre><code>pizzahouse/\n    liminal/\n        env.py\n        versions/\n            &lt;revision_id&gt;_initial_init_revision.py\n    dropdowns/\n        ...\n    entity_schemas/\n        ...\n</code></pre> <p>Tip</p> <p>It is recommended to generate files using your production Benchling tenant. These schemas will be used as the single source of truth for your production tenant as well as other tenants you may have.</p> </li> <li> <p>Add your schema imports to the env.py file. For example:</p> <pre><code>from pizzahouse.dropdowns import *\nfrom pizzahouse.entity_schemas import *\n</code></pre> <p>Warning</p> <p>This is necessary for Liminal to recognize what schemas exist in your environment.</p> </li> <li> <p>Set up is complete! You're now ready to start using your schemas defined in code as the single source of truth for your Benchling tenant(s).</p> </li> </ol>"},{"location":"getting-started/tutorials/","title":"Tutorials","text":"<p>\ud83d\udea7 Video tutorial coming soon! \ud83d\udea7</p>"},{"location":"reference/benchling-connection/","title":"Benchling connection","text":""},{"location":"reference/benchling-connection/#benchlingconnection-class","title":"BenchlingConnection: class","text":"<p>The <code>BenchlingConnection</code> class is used to define the connection information for a particular Benchling tenant. The BenchlingConnection class is defined in your <code>env.py</code> file and it also used to create a BenchlingService object. In the <code>env.py</code> file, the api_client and internal_api parameters are required for the BenchlingConnection object in orderto be used in the migration service. The BenchlingService can be imported from the liminal pacakage and be used to connect to Benchling's SDK, internal API, and/or Postgres warehouse.</p> <pre><code># Example BenchlingConnection definition\nfrom liminal.connection import BenchlingConnection\n\nPROD_CURRENT_REVISION_ID = \"12b31776a755b\"\n\n# It is highly recommended to use a secrets manager to store your credentials.\nconnection = BenchlingConnection(\n    tenant_name=\"pizzahouse-prod\",\n    tenant_alias=\"prod\",\n    current_revision_id_var_name=\"PROD_CURRENT_REVISION_ID\",\n    api_client_id=\"my-secret-api-client-id\",\n    api_client_secret=\"my-secret-api-client-secret\",\n    warehouse_connection_string=\"my-warehouse-connection-string\",\n    internal_api_admin_email=\"my-secret-internal-api-admin-email\",\n    internal_api_admin_password=\"my-secret-internal-api-admin-password\",\n)\n</code></pre>"},{"location":"reference/benchling-connection/#parameters","title":"Parameters","text":"<ul> <li> <p>tenant_name: str</p> <p>The name of the tenant. ex: {tenant_name}.benchling.com</p> </li> <li> <p>tenant_alias: Optional[str] = None</p> <p>The alias of the tenant name. This is optional and is used as an alternate value when using the Liminal CLI</p> </li> <li> <p>current_revision_id_var_name: str = \"\"</p> <p>The name of the variable that contains the current revision id. If not provided, a derived name will be generated based on the tenant name/alias. Ex: {tenant_alias}_CURRENT_REVISION_ID or {tenant_name}_CURRENT_REVISION_ID if alias is not provided.</p> </li> <li> <p>api_client_id: Optional[str] = None</p> <p>The id of the API client.</p> </li> <li> <p>api_client_secret: Optional[str] = None</p> <p>The secret of the API client.</p> </li> <li> <p>warehouse_connection_string: Optional[str] = None</p> <p>The connection string for the warehouse.</p> </li> <li> <p>internal_api_admin_email: Optional[str] = None</p> <p>The email of the internal API admin.</p> </li> <li> <p>internal_api_admin_password: Optional[str] = None</p> <p>The password of the internal API admin.</p> </li> </ul>"},{"location":"reference/benchling-session/","title":"Benchling session","text":""},{"location":"reference/benchling-session/#benchlingservice-class","title":"BenchlingService: class","text":"<p>The BenchlingService class takes in a BenchlingConnection object and is used to directly interact with Benchling's SDK, internal API, and Postgres warehouse. This class is surfaced for users so that there is one standard interface for interacting with Benchling around your codebase. Liminal's BenchlingService handles all session management and is a subclass of Benchling's SDK, so all functionality of Benchling's SDK is available.</p> <pre><code>from liminal.connection import BenchlingConnection\nfrom liminal.connection import BenchlingService\n\nconnection = BenchlingConnection(\n    ...\n)\nbenchling_service = BenchlingService(connection, use_internal_api=True, use_warehouse=True) # enable all connections\n\n# Use Benchling SDK\nentity = benchling_service.custom_entities.get_by_id(\"my-entity-id\")\n\n# Use to query Postgres warehouse using SQLAlchemy\nwith benchling_service() as session:\n    entity = session.query(Pizza).all()\n</code></pre>"},{"location":"reference/benchling-session/#parameters","title":"Parameters","text":"<ul> <li> <p>connection: BenchlingConnection</p> <p>The connection object that contains the credentials for the Benchling tenant.</p> </li> <li> <p>use_api: bool</p> <p>Whether to connect to the Benchling SDK. Defaults to True. (See Benchling SDK documentation here)</p> </li> <li> <p>use_internal_api: bool</p> <p>Whether to connect to the Benchling internal API. Defaults to False.</p> </li> <li> <p>use_warehouse: bool</p> <p>Whether to connect to the Benchling Postgres warehouse. Defaults to False. See SQLAlchemy documentation here for more information.</p> </li> </ul>"},{"location":"reference/dropdowns/","title":"Dropdowns","text":""},{"location":"reference/dropdowns/#dropdown-schema-class","title":"Dropdown Schema: class","text":"<p>Below is an example of a dropdown schema defined in code. The <code>__benchling_name__</code> property is used to define the name of the dropdown in Benchling, while the <code>__allowed_values__</code> property is used to define the values of the dropdown.</p> <pre><code># Example dropdown definition\nfrom liminal.base.base_dropdown import BaseDropdown\n\n\nclass Toppings(BaseDropdown):\n    __benchling_name__ = \"Toppings\"\n    __allowed_values__ = [\"Pepperoni\", \"Mushroom\", \"Onion\", \"Sausage\", \"Bacon\"]\n</code></pre>"},{"location":"reference/dropdowns/#parameters","title":"Parameters","text":"<ul> <li> <p>benchling_name: str</p> <p>The name of the dropdown in Benchling. There can be no duplicate dropdown names in Benchling.</p> </li> <li> <p>allowed_values: list[str]</p> <p>The list of values for the dropdown. Order matters and reflects the order of the dropdown in Benchling. Values must be unique.</p> </li> </ul>"},{"location":"reference/entity-schemas/","title":"Entity schemas","text":""},{"location":"reference/entity-schemas/#entity-schema-class","title":"Entity Schema: class","text":"<p>Below is an example of a custom entity schema defined in code. All Liminal entity schema classes inherit from Liminal's BaseModel and uses SQLAlchemy behind the scenes to create an ORM. Liminal provides base classes and clear abstractions to provide a standardized way to define entity schemas in code. However, you are still able to use raw SQLAlchemy to interact with the schemas when necessary.</p> <p>The properties defined in the <code>SchemaProperties</code> object and <code>Column</code> objects align with the properties shown on the Benchling website. This is how Liminal defines your Benchling entity schema in code. Any of these properties can be manipulated to change the definition of the entity schema. Updates to the schema or the addition/archival of schemas are automatically detected by Liminal's migration service, which is run using the <code>liminal autogenerate ...</code> command. Refer to the First Migration page to run your first migration.</p> <p>Below, we will go through the different components of defining an entity schema class.</p> <pre><code>from liminal.base.name_template_parts import RegistryIdentifierNumberPart, TextPart\nfrom liminal.orm.relationship import single_relationship\nfrom liminal.orm.schema_properties import SchemaProperties\nfrom liminal.orm.column import Column\nfrom liminal.orm.name_template import NameTemplate\nfrom liminal.validation import BenchlingValidator\nfrom liminal.enums import BenchlingEntityType, BenchlingFieldType, BenchlingNamingStrategy\nfrom sqlalchemy.orm import Query, Session\nfrom liminal.orm.mixins import CustomEntityMixin\nfrom liminal.orm.base_model import BaseModel\nfrom pizzahouse.dropdowns import Toppings\n\nclass Pizza(BaseModel, CustomEntityMixin):\n    __schema_properties__ = SchemaProperties(\n        name=\"Pizza\",\n        warehouse_name=\"pizza\",\n        prefix=\"PI\",\n        entity_type=BenchlingEntityType.CUSTOM_ENTITY,\n        naming_strategies={\n            BenchlingNamingStrategy.REPLACE_NAME_WITH_ID,\n            BenchlingNamingStrategy.IDS_FROM_NAMES,\n            BenchlingNamingStrategy.NEW_IDS,\n        },\n        mixture_schema_config=None,\n    )\n    __name_template__ = NameTemplate(parts=[TextPart(value=\"Pizza\"), RegistryIdentifierNumberPart()])\n\n    dough = Column(name=\"dough\", type=BenchlingFieldType.ENTITY_LINK, required=True, entity_link=\"dough\")\n    cook_temp = Column(name=\"cook_temp\", type=BenchlingFieldType.INTEGER, required=False)\n    cook_time = Column(name=\"cook_time\", type=BenchlingFieldType.INTEGER, required=False)\n    toppings = Column(name=\"toppings\", type=BenchlingFieldType.DROPDOWN, required=False, dropdown=Toppings)\n    customer_review = Column(name=\"customer_review\", type=BenchlingFieldType.INTEGER, required=False)\n    slices = Column(name=\"slices\", type=BenchlingFieldType.ENTITY_LINK, required=False, is_multi=True, entity_link=\"slice\")\n\n    dough_entity = single_relationship(\"Dough\", dough)\n    slice_entities = multi_relationship(\"Slice\", \"Pizza\", \"slices\")\n\n    def __init__(\n        self,\n        dough: str,\n        cook_temp: int | None = None,\n        cook_time: int | None = None,\n        customer_review: int | None = None,\n    ):\n        self.dough = dough\n        self.cook_temp = cook_temp\n        self.cook_time = cook_time\n        self.customer_review = customer_review\n</code></pre>"},{"location":"reference/entity-schemas/#mixins-class","title":"Mixins: class","text":"<p>All Liminal entity schema classes must inherit from one of the mixins in the mixins module. The mixin provides the base columns for the specific entity schema type. For example, the <code>CustomEntityMixin</code> provides the base columns for a custom entity schema. To learn more, check out the SQLAlchemy documentation here.</p>"},{"location":"reference/entity-schemas/#schema-properties-class","title":"Schema Properties: class","text":""},{"location":"reference/entity-schemas/#parameters","title":"Parameters","text":"<ul> <li> <p>name: str</p> <p>The name of the entity schema. Must be unique across all entity schemas.</p> </li> <li> <p>warehouse_name: str</p> <p>The warehouse name of the entity schema. Must be unique across all entity schemas.</p> </li> </ul> <p>Note</p> <p>The warehouse names are used as keys across liminal and are used as entity_link values in Columns.</p> <p>Warning</p> <p>If warehouse access is not enabled on your tenant, you will be unable to update the warehouse name.</p> <p>Liminal assumes the Benchling generated warehouse name to be <code>to_snake_case(name)</code>.</p> <ul> <li> <p>prefix: str</p> <p>The prefix of the entity schema. Must be unique across all entity schemas.</p> </li> <li> <p>entity_type: BenchlingEntityType</p> <p>The type of entity schema. Type must be one of the values from the BenchlingEntityType enum.</p> </li> <li> <p>naming_strategies: set[BenchlingNamingStrategy]</p> <p>The naming strategies for the entity schema. Must be a set of values from the BenchlingNamingStrategy enum.</p> </li> <li> <p>mixture_schema_config: MixtureSchemaConfig | None</p> <p>The mixture schema configuration for the entity schema. Must be defined as a MixtureSchemaConfig object.</p> </li> <li> <p>use_registry_id_as_label: bool | None = None</p> <p>Flag for configuring the chip label for entities. Determines if the chip will use the Registry ID as the main label for items.</p> </li> <li> <p>include_registry_id_in_chips: bool | None = None</p> <p>Flag for configuring the chip label for entities. Determines if the chip will include the Registry ID in the chip label.</p> </li> <li> <p>constraint_fields: set[str] | None</p> <p>Set of constraints for field values for the schema. Must be a set of column names that specify that their values must be a unique combination within an entity. If the entity type is a Sequence, \"bases\" can be a constraint field.</p> </li> <li> <p>_archived: bool | None = None</p> <p>Private attribute used to set the archived status of the schema.</p> </li> </ul> <p>Tip</p> <p>When schemas (and fields) are archived, they still existing the Benchling warehouse. Using _archived is useful when you need to access archived data.</p>"},{"location":"reference/entity-schemas/#column-class","title":"Column: class","text":"<p>Warning</p> <p>If warehouse access is not enabled on your tenant, you will be unable to update the warehouse name for fields.</p> <p>Liminal will enforce that the column variable name (which represents the warehouse name) matches the Benchling generated warehouse name, which Liminal assumes to be <code>to_snake_case(name)</code>.</p>"},{"location":"reference/entity-schemas/#parameters_1","title":"Parameters","text":"<ul> <li> <p>name: str</p> <p>The external facing name of the column.</p> </li> <li> <p>type: BenchlingFieldType</p> <p>The type of the field. Type must be one of the values from the BenchlingFieldType enum.</p> </li> <li> <p>required: bool</p> <p>Whether the field is required.</p> </li> <li> <p>is_multi: bool = False</p> <p>Whether the field is a multi-value field. Defaults to False.</p> </li> <li> <p>parent_link: bool = False</p> <p>Whether the field is a parent link field. Defaults to False.</p> </li> <li> <p>tooltip: str | None = None</p> <p>The tooltip for the field. Defaults to None.</p> </li> <li> <p>dropdown: Type[BaseDropdown] | None = None</p> <p>The dropdown object for the field. The dropdown object must inherit from BaseDropdown and the type of the Column must be <code>BenchlingFieldType.DROPDOWN</code>. Defaults to None.</p> </li> <li> <p>entity_link: str | None = None</p> <p>The entity link for the field. The entity link must be the <code>warehouse_name</code> as a string of the entity schema that the field is linking to. The type of the Column must be <code>BenchlingFieldType.ENTITY_LINK</code> in order to be valid. Defaults to None.</p> </li> <li> <p>_archived: bool = False</p> <p>Private attribute used to set the archived status of the column.  Useful when you need to access archived data and want to define archived fields.</p> </li> <li> <p>_warehouse_name: str | None = None</p> <p>Private attribute used to set the warehouse name of the column. This is useful when the variable name is not the same as the warehouse name.</p> </li> </ul>"},{"location":"reference/entity-schemas/#relationships-module","title":"Relationships: module","text":"<p>If there are columns that are entity links, that means the value of the column is the linked entity id or ids. You can easily define relationships using Liminal's wrapper functions around SQLAlchemy. The two relationships to define are <code>single_relationship</code> and <code>multi_relationship</code>, and examples are shown above.</p> <pre><code># single_relationship is used for a non-multi field where there is a one-to-one relationship from the current class to the target class.\nfrom liminal.orm.relationship import single_relationship, multi_relationship\n\nsingle_relationship(target_class_name: str, entity_link_field: Column, backref: str | None = None) -&gt; RelationshipProperty\n\n# multi_relationship is used for a multi field where there is a \"one-to-many\" relationship from the current class to the target class.\n# NOTE: This is not a normal one-to-many relationship. The multi field is represented as a list of entity ids.\nmulti_relationship(target_class_name: str, current_class_name: str, entity_link_field_name: str) -&gt; RelationshipProperty\n</code></pre> <p>How do I access the joined entity or entities?</p> <pre><code>connection = BenchlingConnection(...)\nbenchling_service = BenchlingService(connection, use_db=True)\n\nwith benchling_service as session:\n    pizza_entity = session.query(Pizza).first()\n\n    # NOTE: Accessing the relationship entities must be done within the session context.\n    dough = pizza_entity.dough_entity\n    slices = pizza_entity.slice_entities\n</code></pre>"},{"location":"reference/operations/","title":"Operations","text":""},{"location":"reference/operations/#operations-class","title":"Operations: class","text":"<p>Operations are the building blocks of a revision file. They represent a singular API call that does a specific action to change the Benchling model. They are generated by the <code>liminal autogenerate ...</code> command in the upgrade/downgrade functions of a revision file and can also be created manually. Operations are used to create, update, and archive entity schemas, dropdowns, and entity schema fields (a full list of operations can be found below). Operations have a couple of common functionalities:</p> <pre><code># Defines the operation for archiving the 'dough' field on the 'pizza' entity schema\nexample_operation = ArchiveEntitySchemaField('pizza', 'dough')\n\n# Executes the operation. This will run an action using the Benchling API to execute a change. In this case, it will archive the 'dough' field on the 'pizza' entity schema.\nexample_operation.execute()\n\n# Returns a description of what the operation will do.\n# Ex: 'pizza: Archiving entity schema field 'dough'.'\nexample_operation.describe_operation()\n\n# Returns a description of the current state of the operation.\n# Ex: 'pizza: Entity schema field 'dough' is defined in Benchling but not in code.'\nexample_operation.describe()\n\n# Validates the operation. Note: Not all operations have a validate() method.\nexample_operation.validate()\n</code></pre>"},{"location":"reference/operations/#dropdown-operations","title":"Dropdown Operations","text":"Operation Class Description Order CreateDropdown Creates a new dropdown with specified options. 1 UpdateDropdownName Updates the name of an existing dropdown. 2 UnarchiveDropdown Unarchives an archived dropdown. 3 CreateDropdownOption Creates a new option in an existing dropdown. 4 UpdateDropdownOption Updates the name of an existing option in a dropdown. 5 ArchiveDropdownOption Archives an existing option in a dropdown. 6 ReorderDropdownOptions Reorders the options in an existing dropdown. 7 ArchiveDropdown Archives an existing dropdown. 18"},{"location":"reference/operations/#entity-schema-operations","title":"Entity Schema Operations","text":"Operation Class Description Order CreateEntitySchema Creates a new entity schema with specified fields. 8 UpdateEntitySchema Updates the properties of an existing entity schema. 9 UnarchiveEntitySchema Unarchives an archived entity schema. 10 CreateEntitySchemaField Creates a new field in an existing entity schema. 11 UnarchiveEntitySchemaField Unarchives an archived field in an entity schema. 12 UpdateEntitySchemaField Updates the properties of an existing field in an entity schema. 13 ArchiveEntitySchemaField Archives an existing field in an entity schema. 14 UpdateEntitySchemaNameTemplate Updates the name template of an existing entity schema. 15 ReorderEntitySchemaFields Reorders the fields in an existing entity schema. 16 ArchiveEntitySchema Archives an existing entity schema. 17"},{"location":"reference/revision-file/","title":"Revision file","text":""},{"location":"reference/revision-file/#example-revision-file","title":"Example Revision File","text":"<p>Below is an example of a revision file that gets generated by the <code>liminal autogenerate</code> command. This flow was heavily inspired by the Alembic migration workflow. When <code>liminal upgrade ...</code> is run, the operations in the <code>upgrade()</code> function are executed and when <code>liminal downgrade ...</code> is run, the operations in the <code>downgrade()</code> function are executed. Each revision is linearly linked to a previous revision through the IDs, creating a timeline of revisions/operations. This allows for the user to traverse the history of their Benchling model.</p> <pre><code>'''\ntest\n\nRevision ID: c3a9cd009713\nRevises: d28335bffaba\nCreate Date: 2024-10-26 10:33:26.390965\n'''\n\nimport liminal.external as b\n\n# revision identifiers, used by Liminal.\nrevision = \"c3a9cd009713\"\ndown_revision = \"d28335bffaba\"\n\n\n# ### commands auto generated by Liminal - please review (and adjust if needed)! ###\ndef upgrade() -&gt; list[b.BaseOperation]:\n    return [b.ArchiveEntitySchemaField('pizza', 'dough')]\n\n# ### commands auto generated by Liminal - please review (and adjust if needed)! ###\ndef downgrade() -&gt; list[b.BaseOperation]:\n    return [b.UnarchiveEntitySchemaField('pizza', 'dough')]\n</code></pre> <p>Warning</p> <p>Generated revision files cannot automatically detect changes to warehouse names. To address this, you must manually edit the revision file.</p> <p>Updating Entity Schema warehouse name: <pre><code>b.UpdateEntitySchema('old_warehouse_name', \n    b.BaseSchemaProperties(warehouse_name='new_warehouse_name')\n)\n</code></pre></p> <p>Updating Entity Schema Field warehouse name: <pre><code>b.UpdateEntitySchemaField('entity_schema_warehouse_name', 'field_warehouse_name', \nb.BaseFieldProperties(warehouse_name='new_warehouse_field_name')\n)\n</code></pre></p> <p>Updating Dropdown warehouse name: <pre><code>b.UpdateDropdownName('old_warehouse_name', 'new_warehouse_name')\n</code></pre></p>"},{"location":"reference/validation/","title":"Validation","text":"<p>When using Benchling to store essential data, it is important to validate the data to ensure accuracy and consistency. Liminal provides an easy way to define \"validators\" on entity schemas that ensure entities adhere to your defined business logic. These validators can be run easily by calling the <code>validate()</code> method on the entity schema.</p> <p>Note</p> <p>Warehouse access is required to run validators.</p>"},{"location":"reference/validation/#defining-a-liminal-validator-decorator","title":"Defining a Liminal Validator decorator","text":"<p>Any functions decorated with <code>liminal_validator</code> are detected as validators for the entity schema. Each validator returns a <code>BenchlingValidatorReport</code> object per entity it is run on, with either <code>valid=True</code> or <code>valid=False</code>. If no errors are raised when it is run on an entity, the report will be valid. If an error is raised, the report will be invalid.</p> <pre><code>from liminal.validation import ValidationSeverity, liminal_validator\n\nclass Pizza(BaseModel, CustomEntityMixin):\n    ...\n\n    @liminal_validator(ValidationSeverity.MED)\n    def cook_time_and_temp_validator(self) -&gt; None:\n        if self.cook_time is not None and self.cook_temp is None:\n            raise ValueError(\"Cook temp is required if cook time is set\")\n        if self.cook_time is None and self.cook_temp is not None:\n            raise ValueError(\"Cook time is required if cook temp is set\")\n</code></pre>"},{"location":"reference/validation/#parameters","title":"Parameters","text":"<ul> <li> <p>validator_level: ValidationSeverity</p> <p>The severity of the validator. Defaults to <code>ValidationSeverity.LOW</code>.</p> </li> <li> <p>validator_name: str | None</p> <p>The name of the validator. Defaults to converting the function name to PascalCase.</p> </li> </ul>"},{"location":"reference/validation/#running-validation","title":"Running Validation","text":"<p>To run validation using Liminal, call the <code>validate()</code> method on the entity schema:</p> <pre><code>with BenchlingSession(benchling_connection, with_db=True) as session:\n    reports = Pizza.validate(session, only_invalid=True)\n</code></pre> <p>Tip</p> <p>The <code>validate_to_df</code> method returns a pandas DataFrame with all the reports. For example:</p> <pre><code>with BenchlingSession(benchling_connection, with_db=True) as session:\n    df = Pizza.validate_to_df(session, only_invalid=True)\n</code></pre>"},{"location":"reference/validation/#parameters_1","title":"Parameters","text":"<ul> <li> <p>session : Session</p> <p>The Benchling database session.</p> </li> <li> <p>base_filters: BaseValidatorFilters | None</p> <p>Filters to apply to the query.</p> </li> <li> <p>only_invalid: bool</p> <p>If <code>True</code>, only returns reports for entities that failed validation.</p> </li> </ul>"},{"location":"reference/validation/#returns","title":"Returns","text":"<ul> <li> <p>list[BenchlingValidatorReport]</p> <p>List of reports from running all validators on all entities returned from the query.</p> </li> </ul>"},{"location":"reference/validation/#benchlingvalidatorreport-classhttpsgithubcomdynotxliminal-ormblobmainliminalvalidationinitpyl13","title":"BenchlingValidatorReport: [class](https://github.com/dynotx/liminal-orm/blob/main/liminal/validation/init.py#L13","text":"<p>These reports are filled out by the <code>liminal_validator</code> decorator behind the scenes.</p>"},{"location":"reference/validation/#parameters_2","title":"Parameters","text":"<ul> <li> <p>valid : bool</p> <p>Indicates whether the validation passed or failed.</p> </li> <li> <p>model : str</p> <p>The name of the model being validated. (eg: Pizza)</p> </li> <li> <p>level : ValidationSeverity</p> <p>The severity level of the validation report.</p> </li> <li> <p>validator_name : str | None</p> <p>The name of the validator that generated this report. (eg: CookTimeAndTempValidator)</p> </li> <li> <p>entity_id : str | None</p> <p>The entity ID of the entity being validated.</p> </li> <li> <p>registry_id : str | None</p> <p>The registry ID of the entity being validated.</p> </li> <li> <p>entity_name : str | None</p> <p>The name of the entity being validated.</p> </li> <li> <p>message : str | None</p> <p>A message describing the result of the validation.</p> </li> <li> <p>creator_name : str | None</p> <p>The name of the creator of the entity being validated.</p> </li> <li> <p>creator_email : str | None</p> <p>The email of the creator of the entity being validated.</p> </li> <li> <p>updated_date : datetime | None</p> <p>The date the entity was last updated.</p> </li> </ul>"},{"location":"reference/validation/#basevalidatorfilters-class","title":"BaseValidatorFilters: class","text":"<p>This class is used to pass base filters to benchling warehouse database queries. These columns are found on all tables in the benchling warehouse database.</p>"},{"location":"reference/validation/#parameters_3","title":"Parameters","text":"<ul> <li> <p>created_date_start: date | None</p> <p>Start date for created date filter.</p> </li> <li> <p>created_date_end: date | None</p> <p>End date for created date filter.</p> </li> <li> <p>updated_date_start: date | None</p> <p>Start date for updated date filter.</p> </li> <li> <p>updated_date_end: date | None</p> <p>End date for updated date filter.</p> </li> <li> <p>entity_ids: list[str] | None</p> <p>List of entity IDs to filter by.</p> </li> <li> <p>creator_full_names: list[str] | None</p> <p>List of creator full names to filter by.</p> </li> </ul>"}]}